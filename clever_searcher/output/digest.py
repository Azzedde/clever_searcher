"""Digest generation in multiple formats (Markdown, HTML, JSON)"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from jinja2 import Template

from ..core.fetcher import ContentDocument
from ..core.summarizer import StructuredSummary
from ..utils.config import get_output_dir, settings

logger = logging.getLogger(__name__)


class DigestItem:
    """Represents a single item in a digest"""
    
    def __init__(
        self,
        document: ContentDocument,
        summary: Optional[StructuredSummary] = None,
        score: float = 0.0,
        rank: int = 0,
    ):
        self.document = document
        self.summary = summary
        self.score = score
        self.rank = rank
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'rank': self.rank,
            'score': self.score,
            'document': self.document.to_dict(),
            'summary': self.summary.to_dict() if self.summary else None,
        }


class DigestGenerator:
    """Generates digests in multiple formats"""
    
    def __init__(self, output_dir: Path = None):
        self.output_dir = output_dir or get_output_dir()
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, Template]:
        """Load Jinja2 templates for different formats"""
        
        markdown_template = """# {{ title }}

**Generated:** {{ timestamp }}  
**Category:** {{ category }}  
**Total Items:** {{ total_items }}  
**Query:** {{ query }}

{% if summary_stats %}
## Summary Statistics

- **Average Score:** {{ summary_stats.avg_score|round(2) }}
- **Top Domains:** {{ summary_stats.top_domains|join(", ") }}
- **Total Content:** {{ summary_stats.total_content_length }} characters
- **Unique Sources:** {{ summary_stats.unique_sources }}

{% endif %}
---

{% for item in items %}
## {{ item.rank }}. {{ item.document.title }}

**URL:** [{{ item.document.url }}]({{ item.document.url }})  
**Domain:** {{ item.document.domain }}  
**Score:** {{ item.score|round(3) }}
{% if item.document.author %}**Author:** {{ item.document.author }}  {% endif %}
{% if item.document.published_date %}**Published:** {{ item.document.published_date }}  {% endif %}
**Content Length:** {{ item.document.content_length }} characters

{% if item.summary %}
### Summary

**TL;DR:** {{ item.summary.tldr }}

{% if item.summary.bullets %}
**Key Points:**
{% for bullet in item.summary.bullets %}
- {{ bullet }}
{% endfor %}
{% endif %}

{% if item.summary.tags %}
**Tags:** {{ item.summary.tags|join(", ") }}
{% endif %}

{% if item.summary.entities %}
**Entities:** {{ item.summary.entities|join(", ") }}
{% endif %}

{% if item.summary.read_time_minutes > 0 %}
**Estimated Read Time:** {{ item.summary.read_time_minutes }} minutes
{% endif %}

{% endif %}

### Content Preview

{{ item.document.content[:500] }}{% if item.document.content|length > 500 %}...{% endif %}

---

{% endfor %}

## Metadata

- **Generated by:** Clever Searcher
- **Timestamp:** {{ timestamp }}
- **Configuration:** {{ config|tojson }}
"""

        html_template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 30px; }
        .stats { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; }
        .item { border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 20px; }
        .item-header { display: flex; justify-content: between; align-items: center; margin-bottom: 15px; }
        .rank { background: #007bff; color: white; padding: 5px 10px; border-radius: 20px; font-weight: bold; }
        .score { background: #28a745; color: white; padding: 5px 10px; border-radius: 4px; font-size: 0.9em; }
        .url { color: #007bff; text-decoration: none; }
        .url:hover { text-decoration: underline; }
        .summary { background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 15px 0; }
        .tags { margin: 10px 0; }
        .tag { background: #e9ecef; padding: 3px 8px; border-radius: 12px; font-size: 0.85em; margin-right: 5px; }
        .content-preview { background: #fff; border-left: 4px solid #007bff; padding: 15px; margin: 15px 0; font-style: italic; }
        .metadata { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="header">
        <h1>{{ title }}</h1>
        <p><strong>Generated:</strong> {{ timestamp }}</p>
        <p><strong>Category:</strong> {{ category }}</p>
        <p><strong>Total Items:</strong> {{ total_items }}</p>
        {% if query %}<p><strong>Query:</strong> {{ query }}</p>{% endif %}
    </div>

    {% if summary_stats %}
    <div class="stats">
        <h2>Summary Statistics</h2>
        <ul>
            <li><strong>Average Score:</strong> {{ summary_stats.avg_score|round(2) }}</li>
            <li><strong>Top Domains:</strong> {{ summary_stats.top_domains|join(", ") }}</li>
            <li><strong>Total Content:</strong> {{ summary_stats.total_content_length|int }} characters</li>
            <li><strong>Unique Sources:</strong> {{ summary_stats.unique_sources }}</li>
        </ul>
    </div>
    {% endif %}

    {% for item in items %}
    <div class="item">
        <div class="item-header">
            <span class="rank">{{ item.rank }}</span>
            <span class="score">{{ "%.3f"|format(item.score) }}</span>
        </div>
        
        <h2><a href="{{ item.document.url }}" class="url" target="_blank">{{ item.document.title }}</a></h2>
        
        <p><strong>Domain:</strong> {{ item.document.domain }}</p>
        {% if item.document.author %}<p><strong>Author:</strong> {{ item.document.author }}</p>{% endif %}
        {% if item.document.published_date %}<p><strong>Published:</strong> {{ item.document.published_date }}</p>{% endif %}
        <p><strong>Content Length:</strong> {{ "{:,}"|format(item.document.content_length) }} characters</p>

        {% if item.summary %}
        <div class="summary">
            <h3>Summary</h3>
            <p><strong>TL;DR:</strong> {{ item.summary.tldr }}</p>
            
            {% if item.summary.bullets %}
            <h4>Key Points:</h4>
            <ul>
                {% for bullet in item.summary.bullets %}
                <li>{{ bullet }}</li>
                {% endfor %}
            </ul>
            {% endif %}

            {% if item.summary.tags %}
            <div class="tags">
                <strong>Tags:</strong>
                {% for tag in item.summary.tags %}
                <span class="tag">{{ tag }}</span>
                {% endfor %}
            </div>
            {% endif %}

            {% if item.summary.entities %}
            <p><strong>Entities:</strong> {{ item.summary.entities|join(", ") }}</p>
            {% endif %}

            {% if item.summary.read_time_minutes > 0 %}
            <p><strong>Estimated Read Time:</strong> {{ item.summary.read_time_minutes }} minutes</p>
            {% endif %}
        </div>
        {% endif %}

        <div class="content-preview">
            {{ item.document.content[:500] }}{% if item.document.content|length > 500 %}...{% endif %}
        </div>
    </div>
    {% endfor %}

    <div class="metadata">
        <p><strong>Generated by:</strong> Clever Searcher</p>
        <p><strong>Timestamp:</strong> {{ timestamp }}</p>
    </div>
</body>
</html>"""

        return {
            'markdown': Template(markdown_template),
            'html': Template(html_template),
        }
    
    def generate_digest(
        self,
        items: List[DigestItem],
        title: str,
        category: str = "",
        query: str = "",
        format_type: str = "markdown",
        filename: str = None,
    ) -> Path:
        """Generate a digest in the specified format"""
        
        if not items:
            logger.warning("No items to generate digest")
            return None
        
        # Generate filename if not provided
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()
            safe_title = safe_title.replace(' ', '_').lower()
            filename = f"{safe_title}_{timestamp}.{format_type}"
        
        output_path = self.output_dir / filename
        
        # Calculate summary statistics
        summary_stats = self._calculate_summary_stats(items)
        
        # Prepare template context
        context = {
            'title': title,
            'category': category,
            'query': query,
            'total_items': len(items),
            'items': items,
            'timestamp': datetime.now().isoformat(),
            'summary_stats': summary_stats,
            'config': {
                'format': format_type,
                'generated_by': 'Clever Searcher',
            }
        }
        
        try:
            if format_type == 'json':
                # JSON format
                json_data = {
                    'metadata': {
                        'title': title,
                        'category': category,
                        'query': query,
                        'total_items': len(items),
                        'timestamp': context['timestamp'],
                        'summary_stats': summary_stats.__dict__ if summary_stats else None,
                    },
                    'items': [item.to_dict() for item in items]
                }
                
                with open(output_path, 'w', encoding='utf-8') as f:
                    json.dump(json_data, f, indent=2, ensure_ascii=False, default=str)
            
            elif format_type in self.templates:
                # Template-based formats (markdown, html)
                template = self.templates[format_type]
                content = template.render(**context)
                
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            else:
                raise ValueError(f"Unsupported format: {format_type}")
            
            logger.info(f"Generated {format_type} digest: {output_path}")
            return output_path
            
        except Exception as e:
            logger.error(f"Failed to generate digest: {e}")
            raise
    
    def _calculate_summary_stats(self, items: List[DigestItem]) -> Optional['SummaryStats']:
        """Calculate summary statistics for the digest"""
        if not items:
            return None
        
        # Calculate statistics
        scores = [item.score for item in items]
        domains = [item.document.domain for item in items]
        content_lengths = [item.document.content_length for item in items]
        
        # Count domain frequency
        domain_counts = {}
        for domain in domains:
            domain_counts[domain] = domain_counts.get(domain, 0) + 1
        
        # Get top domains
        top_domains = sorted(domain_counts.items(), key=lambda x: x[1], reverse=True)[:5]
        top_domain_names = [domain for domain, count in top_domains]
        
        return SummaryStats(
            avg_score=sum(scores) / len(scores),
            total_content_length=sum(content_lengths),
            unique_sources=len(set(domains)),
            top_domains=top_domain_names,
        )
    
    def generate_multiple_formats(
        self,
        items: List[DigestItem],
        title: str,
        category: str = "",
        query: str = "",
        formats: List[str] = None,
    ) -> Dict[str, Path]:
        """Generate digest in multiple formats"""
        
        if formats is None:
            formats = ['markdown', 'html', 'json']
        
        results = {}
        
        for format_type in formats:
            try:
                output_path = self.generate_digest(
                    items=items,
                    title=title,
                    category=category,
                    query=query,
                    format_type=format_type,
                )
                results[format_type] = output_path
            except Exception as e:
                logger.error(f"Failed to generate {format_type} digest: {e}")
        
        return results


class SummaryStats:
    """Summary statistics for a digest"""
    
    def __init__(
        self,
        avg_score: float,
        total_content_length: int,
        unique_sources: int,
        top_domains: List[str],
    ):
        self.avg_score = avg_score
        self.total_content_length = total_content_length
        self.unique_sources = unique_sources
        self.top_domains = top_domains


class DigestManager:
    """Manages digest generation and storage"""
    
    def __init__(self, output_dir: Path = None):
        self.output_dir = output_dir or get_output_dir()
        self.generator = DigestGenerator(self.output_dir)
        self.digest_history: List[Dict[str, Any]] = []
    
    def create_digest_from_results(
        self,
        documents: List[ContentDocument],
        summaries: List[StructuredSummary] = None,
        scores: List[float] = None,
        title: str = "Discovery Results",
        category: str = "",
        query: str = "",
        format_type: str = None,
    ) -> Path:
        """Create digest from discovery results"""
        
        if format_type is None:
            format_type = settings.digest_format
        
        # Create digest items
        items = []
        for i, doc in enumerate(documents):
            summary = summaries[i] if summaries and i < len(summaries) else None
            score = scores[i] if scores and i < len(scores) else 0.0
            
            item = DigestItem(
                document=doc,
                summary=summary,
                score=score,
                rank=i + 1,
            )
            items.append(item)
        
        # Generate digest
        output_path = self.generator.generate_digest(
            items=items,
            title=title,
            category=category,
            query=query,
            format_type=format_type,
        )
        
        # Record in history
        self.digest_history.append({
            'title': title,
            'category': category,
            'query': query,
            'format': format_type,
            'output_path': str(output_path),
            'item_count': len(items),
            'timestamp': datetime.now().isoformat(),
        })
        
        return output_path
    
    def list_digests(self) -> List[Dict[str, Any]]:
        """List all generated digests"""
        digests = []
        
        # Add from history
        digests.extend(self.digest_history)
        
        # Also scan output directory for existing files
        if self.output_dir.exists():
            for file_path in self.output_dir.glob("*"):
                if file_path.suffix in ['.md', '.html', '.json']:
                    # Check if already in history
                    if not any(d['output_path'] == str(file_path) for d in digests):
                        digests.append({
                            'title': file_path.stem,
                            'format': file_path.suffix[1:],
                            'output_path': str(file_path),
                            'timestamp': datetime.fromtimestamp(file_path.stat().st_mtime).isoformat(),
                        })
        
        # Sort by timestamp (newest first)
        digests.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
        
        return digests


# Default instances
default_generator = DigestGenerator()
default_manager = DigestManager()